[opencv官方文档](https://docs.opencv.org/4.8.0/db/da5/tutorial_how_to_scan_images.html)
这一部分的核心是讲解如何遍历像素，以及通过缩减色彩空间来应用这些遍历方法。

对色彩空间进行缩减的原因在于，RGB图像通常包含三个通道（红、绿、蓝），每个通道的像素值范围为0到255。因此，三通道组合后的可能性会有超过1600万种。这种庞大的色彩空间在图像处理时会带来极大的复杂性和计算开销。
# 缩减色彩空间
为了简化处理，我们需要将这些可能性限制到一个更小的范围。逐个像素进行除乘操作显然不切实际，因此可以通过一定的算法实现这一目标。缩减色彩空间的核心思路就是将原本的0到255范围内的值分组归类->table表，从而降低计算复杂度，使后续的图像处理更加高效和可控。通过查表来代替除乘运算。
实现的代码如下
```cpp
uchar table[256];

for (int i = 0; i < 256; ++i)

{

table[i] = (uchar)(divideWith * (i/divideWith));

cout<<(int)table[i]<<" ";

}
```

具体的，我把`divideWith`设置为5，table表的内容如下
![[Pasted image 20240818203301.png]]
## 遍历方法
首先，文中提到了三种遍历像素的方法：

1. **传统的C语言风格遍历**：这种方法效率最高，但需要手动处理内存和指针。
2. **基于迭代器的遍历**：这种方法更加安全，能够避免参数错误的风险，适合大部分情况下的使用。
3. **基于动态地址计算的遍历**：虽然这种方法存在，但实用性不强。

文章中重点展示了如何通过一个查找表（LUT）将色彩空间从0到255压缩到指定范围内，比如将多个色彩值合并成单一的输出值。这种方式在色彩空间缩减应用中非常有效。

最后，文中还比较了这三种方法的效率。非官方的测试结果表明，基于LUT函数的实现速度最快，特别适用于色彩空间的缩减。